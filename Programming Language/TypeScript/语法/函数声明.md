---
tags:
  - TypeScript
---

```typescript
// 函数声明 vs 箭头函数示例

// 1. 函数声明（Functio简单说，函数声明更传统、`this` 动态、可当构造函数、有函数提升；箭头函数语法简洁、`this` 静态继承外层、不能当构造函数、遵循变量提升规则，开发里可根据场景选，像需要动态 `this` 、构造函数场景用函数声明，想简洁固定 `this` （比如回调函数里 ）常用箭头函数 。

// 可选参数与默认值的更多示例
function processData(data: string, options?: { 
    uppercase?: boolean; 
    trim?: boolean 
}): string {
    let result = data;
    
    if (options?.trim) {
        result = result.trim();
    }
    
    if (options?.uppercase) {
        result = result.toUpperCase();
    }
    
    return result;
}

// 函数重载
function format(value: string): string;
function format(value: number): string;
function format(value: boolean): string;
function format(value: string | number | boolean): string {
    if (typeof value === 'string') {
        return `"${value}"`;
    } else if (typeof value === 'number') {
        return value.toFixed(2);
    } else {
        return value ? 'true' : 'false';
    }
}

// 使用示例
console.log(format("hello"));    // "hello"
console.log(format(3.14159));    // "3.14"
console.log(format(true));       // "true"

// 剩余参数（Rest Parameters）
function sum(...numbers: number[]): number {
    return numbers.reduce((acc, num) => acc + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15
```

可选参数与参数默认值，直接执行`y`如果没有被赋值会输出`undefined`laration）
function add(x: number, y: number): number {
    return x + y;
}

// 2. 箭头函数（Arrow Function）赋值给常量
const multiply = (x: number, y: number): number => {
    return x * y;
};

// 3. 箭头函数的简写形式（单表达式）
const divide = (x: number, y: number): number => x / y;

// 4. 函数类型注解
let subtract: (a: number, b: number) => number;
subtract = (a, b) => a - b;

// 5. 可选参数和默认参数
function greet(name: string, age?: number, prefix: string = "Hello"): string {
    if (age !== undefined) {
        return `${prefix}, ${name}! You are ${age} years old.`;
    }
    return `${prefix}, ${name}!`;
}

// 使用示例
console.log(greet("张三"));                    // "Hello, 张三!"
console.log(greet("李四", 25));               // "Hello, 李四! You are 25 years old."
console.log(greet("王五", 30, "Hi"));         // "Hi, 王五! You are 30 years old."
```


在这段 TypeScript 代码里，`add` 是**函数声明（Function Declaration）** ，`multiply` 是**箭头函数（Arrow Function，也叫 Lambda 函数 ）** ，它们主要有这些区别：

### 1. 语法形式

- **函数声明**：用 `function` 关键字开头，有明确的函数名（这里是 `add` ），括号里是参数，接着用 `:` 指定返回值类型，最后用大括号包裹函数体。整体格式是传统的函数定义写法，很直观，符合 JavaScript 早期函数定义的习惯延续（TypeScript 兼容这种写法 ）。
- **箭头函数**：通过 `=>` 语法来定义，没有专门的 `function` 关键字（除了参数和返回值类型标注里可能用到相关逻辑，但语法结构上不用 `function` 开头 ）。它常用来写简洁的匿名函数（不过也能把它赋值给变量，像这里 `multiply` 就成了具名的引用 ），箭头左边是参数列表，右边是函数体，语法更紧凑，是 ES6（ECMAScript 2015 ）引入后很流行的写法，TypeScript 也支持并能结合类型标注使用。其中`add`详单与被声明的变量并赋值，`const`指定了其常量性质

### 2. `this` 指向

- **函数声明（`function` ）**：`this` 的指向是动态的，取决于函数的调用方式。比如作为普通函数调用时，`this` 指向全局对象（浏览器里是 `window` ，Node.js 里是 `global` ，严格模式下 `this` 是 `undefined` ）；作为对象的方法调用时，`this` 指向调用方法的那个对象 。
- **箭头函数**：`this` 是静态的，它的 `this` 继承自外层作用域的 `this` 。也就是说，箭头函数定义时，`this` 就确定好了，不会因为调用方式不同而改变，能解决传统函数 `this` 指向易混淆的问题 。

### 3. 构造函数（能否当构造函数用 `new` 调用 ）

- **函数声明**：可以当作构造函数，用 `new` 关键字去实例化对象（前提是函数体里符合构造函数的逻辑，比如给 `this` 添加属性等 ）。
- **箭头函数**：不能当作构造函数，用 `new` 调用会报错，因为箭头函数没有 `prototype` 属性，也无法通过 `new` 去创建实例、绑定 `this` 等构造函数的行为 。

### 4. 作用域与变量提升

- **函数声明**：存在函数提升（Hoisting ），在代码执行前，函数声明会被提升到当前作用域的顶部，所以可以在函数声明之前调用函数 。例如：

```typescript
// 可以提前调用，不会报错
add(1, 2); 
function add(x: number, y: number): number {
  return x + y;
}
```


- **箭头函数**：不存在函数提升，因为它本质上是变量赋值（把箭头函数赋值给 `multiply` 变量 ），变量提升只是提升变量声明，不会提升函数定义，所以在赋值之前调用会报错 。比如：

```typescript
// 报错，multiply 此时只是声明了，还没赋值箭头函数
multiply(2, 3); 
const multiply = (x: number, y: number): number => {
  return x * y;
};
```


简单说，函数声明更传统、`this` 动态、可当构造函数、有函数提升；箭头函数语法简洁、`this` 静态继承外层、不能当构造函数、遵循变量提升规则，开发里可根据场景选，像需要动态 `this` 、构造函数场景用函数声明，想简洁固定 `this` （比如回调函数里 ）常用箭头函数 。

![[Pasted image 20250813155148.png]]

可选参数与参数默认值，直接执行`y`如果没有被赋值会输出`undefined`
