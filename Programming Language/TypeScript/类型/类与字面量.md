---
tags:
  - TypeScript
  - 类型系统
---

# 类与字面量的区别

在 TypeScript 中，类声明和对象字面量是两种不同的创建对象的方式，它们有着本质的区别。

## 基本概念对比

```typescript
// 第一种：类（class）的声明
class Person {
    name: string;
    age: number;
    
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
    
    greet(): string {
        return `Hello, I'm ${this.name}`;
    }
}

// 第二种：对象字面量
let personObj: { name: string; age: number } = {
    name: "张三",
    age: 25
};

// 使用类创建实例
const personInstance = new Person("李四", 30);

// 对象字面量直接就是一个实例
console.log(personObj.name);           // 直接使用
console.log(personInstance.greet());   // 需要先实例化
```

**核心区别**：类是抽象模板，对象字面量已经是具体实例。

## 字面量类型约束

TypeScript 独有的特性：字面量可以用作精确的类型约束

```typescript
// 字符串字面量类型
const greeting: "hello" = "hello";

// 联合字面量类型 - 替代枚举的轻量选择
function changeDirection(dir: "up" | "down" | "left" | "right"): void {
    console.log(`Moving ${dir}`);
}

// 使用示例
changeDirection("up");        // ✅ 正确
// changeDirection("diagonal"); // ❌ 编译错误

// 数字字面量类型
type HttpStatus = 200 | 404 | 500;
const status: HttpStatus = 200;

// 布尔字面量类型
type IsActive = true;
const active: IsActive = true;

// 对象字面量类型
type Config = {
    readonly env: "development" | "production";
    port: number;
};
```

## 详细区别分析

### 1. 语法与本质

**类声明**：
- 使用 `class` 关键字定义
- 包含构造函数、属性、方法
- 是创建对象的蓝图/模板
- 通过 `new` 关键字实例化

**对象字面量**：
- 直接使用 `{}` 语法创建
- 立即创建一个具体的对象实例  
- 没有构造函数概念
- 不支持通过 `new` 创建多个实例

```typescript
// 类的实例化
const person1 = new Person("Alice", 25);
const person2 = new Person("Bob", 30);

// 对象字面量需要重复定义
const obj1 = { name: "Alice", age: 25 };
const obj2 = { name: "Bob", age: 30 };
```

### 2. 复用性和扩展性

```typescript
// 类支持继承和多态
class Student extends Person {
    studentId: string;
    
    constructor(name: string, age: number, studentId: string) {
        super(name, age);
        this.studentId = studentId;
    }
    
    study(): string {
        return `${this.name} is studying`;
    }
    
    // 重写父类方法
    greet(): string {
        return `Hello, I'm student ${this.name}`;
    }
}

// 对象字面量无法直接继承，需要其他方式
const studentObj = {
    name: "Charlie",
    age: 20,
    studentId: "S001",
    greet() {
        return `Hello, I'm student ${this.name}`;
    }
};
```

### 3. 方法共享

```typescript
// 类的方法在原型上共享，节省内存
const student1 = new Student("Alice", 20, "S001");
const student2 = new Student("Bob", 21, "S002");

console.log(student1.greet === student2.greet); // false (实例方法)
console.log(Student.prototype.greet); // 共享的原型方法

// 对象字面量的方法是独立的
const obj1 = {
    name: "Alice",
    greet() { return `Hello ${this.name}`; }
};

const obj2 = {
    name: "Bob", 
    greet() { return `Hello ${this.name}`; }
};

console.log(obj1.greet === obj2.greet); // false (完全独立)
```

### 4. 类型系统中的角色

```typescript
// 类既是类型也是值
let p: Person = new Person("Alice", 25); // Person作为类型
const PersonConstructor = Person;         // Person作为值

// 接口定义对象结构（推荐方式）
interface PersonInterface {
    name: string;
    age: number;
    greet?(): string;
}

// 对象字面量配合接口
const person: PersonInterface = {
    name: "Bob",
    age: 30,
    greet() {
        return `Hello, I'm ${this.name}`;
    }
};

// 类型别名定义对象类型
type PersonType = {
    name: string;
    age: number;
};
```

## 使用场景建议

### 使用类的情况
```typescript
// 1. 需要创建多个相似对象
class User {
    constructor(public name: string, public email: string) {}
    
    sendEmail(message: string): void {
        console.log(`Sending to ${this.email}: ${message}`);
    }
}

// 2. 需要继承和多态
class AdminUser extends User {
    deleteUser(userId: string): void {
        console.log(`Admin ${this.name} deleted user ${userId}`);
    }
}

// 3. 封装复杂逻辑
class Calculator {
    private history: number[] = [];
    
    add(a: number, b: number): number {
        const result = a + b;
        this.history.push(result);
        return result;
    }
    
    getHistory(): number[] {
        return [...this.history];
    }
}
```

### 使用对象字面量的情况
```typescript
// 1. 配置对象
const apiConfig = {
    baseUrl: "https://api.example.com",
    timeout: 5000,
    retries: 3
};

// 2. 一次性数据结构
const userProfile = {
    name: "Alice",
    preferences: {
        theme: "dark",
        language: "zh-CN"
    }
};

// 3. 简单的数据传输对象
interface Point {
    x: number;
    y: number;
}

const origin: Point = { x: 0, y: 0 };
const destination: Point = { x: 10, y: 20 };
```

## 总结

| 特性 | 类 | 对象字面量 |
|------|----|----|
| 复用性 | 高（可实例化多次） | 低（需要重复定义） |
| 继承 | 支持 | 不直接支持 |
| 封装 | 完整的OOP封装 | 简单的属性集合 |
| 内存效率 | 方法共享，效率高 | 每个对象独立方法 |
| 适用场景 | 复杂业务逻辑 | 简单数据结构 |
| 类型系统 | 既是类型也是值 | 需要接口定义类型 |

**选择建议**：
- **复杂对象、需要复用和继承** → 使用类
- **简单数据结构、配置对象、一次性使用** → 使用对象字面量 + 接口