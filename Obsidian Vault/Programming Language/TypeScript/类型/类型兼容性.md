---
tags:
  - TypeScript
---

```typescript
// 类型兼容性示例

// 结构化类型系统：具有相同结构的类型是兼容的
interface Person {
    name: string;
    age: number;
}

interface Employee {
    name: string;
    age: number;
    department?: string;  // 可选属性
}

// Employee 具有 Person 的所有属性，所以兼容
let person: Person = {
    name: "张三",
    age: 30
};

let employee: Employee = {
    name: "李四",
    age: 25,
    department: "IT"
};

// 兼容：Employee 包含 Person 的所有必需属性
person = employee;  // ✅ 可以赋值

// 不兼容：Person 缺少 Employee 可能需要的属性
// employee = person;  // ❌ 如果 department 是必需的则报错
```

```ts
class foo1
{
    name:string;
    age:number;
}

class foo2
{
    name:string;
    age:number;
}

let foo : foo1 = new foo2();
```
相同结构兼容

```typescript
// 接口和类的兼容性
interface IShape {
    area(): number;
}

class Circle {
    radius: number = 5;
    
    area(): number {
        return Math.PI * this.radius ** 2;
    }
}

class Rectangle {
    width: number = 10;
    height: number = 5;
    
    area(): number {
        return this.width * this.height;
    }
}

// 接口和类兼容：只要实现了接口的方法即可
let shape: IShape = new Circle();    // ✅
shape = new Rectangle();             // ✅

// 函数参数兼容性：参数少的可以兼容参数多的
type Handler1 = (a: number) => void;
type Handler2 = (a: number, b: string) => void;

let handler1: Handler1 = (num) => console.log(num);
let handler2: Handler2 = (num, str) => console.log(num, str);

// 参数少的可以赋值给参数多的（逆变）
handler2 = handler1;  // ✅ 可以忽略多余的参数

// 但参数多的不能赋值给参数少的
// handler1 = handler2;  // ❌ 错误
```
接口和类的兼容一致
对函数本身来说，函数参数少的能兼容参数多的，和类和接口相反

复杂向简单兼容，所以不需要向`C#`那样用接口或者基类抽出来？这样不靠人来指明类型约束岂不是会在编译期间消耗性能？