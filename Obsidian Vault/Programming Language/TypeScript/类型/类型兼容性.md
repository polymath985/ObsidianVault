---
tags:
  - TypeScript
---
![[Pasted image 20250814144456.png]]

```ts
class foo1
{
    name:string;
    age:number;
}

class foo2
{
    name:string;
    age:number;
}

let foo : foo1 = new foo2();
```
相同结构兼容

![[Pasted image 20250814144933.png]]
接口和类的兼容一致
对函数本身来说，函数参数少的能兼容参数多的，和类和接口相反

| 类型场景        | 兼容性兼容性核心规则                                                       | 特殊约束                                           | 示例                                                                                                                                              |
| ----------- | ---------------------------------------------------------------- | ---------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| **类与类之间**   | 结构一致（属性类型、方法签名匹配），公共成员完全匹配                                       | 包含 `private`/`protected` 成员时，必须是同一类或存在继承关系才能兼容 | <br>class A { x: number }<br>class B { x: number }<br>const a: A = new B()                                                                      |
| **类与接口之间**  | 类的实例结构与接口完全匹配（类实现接口所有成员，类型一致）                                    | 无需显式 `implements`，但显式声明可强制检查                   | <br>interface I { x: number }<br>class C { x: number }<br>const i: I = new C() // 合法                                                            |
| **接口与接口之间** | 子接口包含父接口所有成员（属性和方法），支持多接口合并                                      | 同名成员类型必须一致（基本类型需完全相同，对象类型需结构兼容）                | <br>interface X { a: number }<br>interface Y extends X { b: string }<br>const y: X = { a: 1, b: '2' }                                           |
| **函数与函数之间** | 参数数量：目标函数参数数量 ≤ 源函数；参数类型：源函数参数可赋值给目标函数参数；返回值类型：源函数返回值可赋值给目标函数返回值 | 可选参数和剩余参数视为兼容；函数重载仅比较签名                        | ```ts<br>```<br>type F1 = (a: number) => void<br>type F2 = (a: number, b?: string) => void<br>const f: F1 = (a) => {}<br>const f2: F2 = f // 合法 |
| **类与函数之间**  | 类的构造函数参数列表与函数参数列表兼容，且类实例结构与函数返回值类型兼容                             | 类作为值时，其类型为构造函数类型，需与目标函数类型（参数、返回值）匹配            | <br>type Creator = new (x: number) => { x: number }<br>class D { constructor(public x: number) {} }<br>const c: Creator = D                     |
| **接口与函数之间** | 接口定义的函数类型与目标函数类型签名一致（参数、返回值匹配）                                   | 接口可描述函数结构（`(params) => returnType`），与实际函数签名对比  | <br>interface Func { (a: number): string }<br>const fn: Func = (n) => n.toString()                                                              |


复杂向简单兼容，所以不需要向`C#`那样用接口或者基类抽出来？这样不靠人来指明类型约束岂不是会在编译期间消耗性能？