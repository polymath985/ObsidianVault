---
tags:
  - CPP
---

# C++函数的[[值和引用|引用]]传参

- 在C++中，取地址符&承担了表明传入参数是引用的责任
	
```
//下列代码中，会直接修改传入vec的原始值，而非创建副本
void TestFunc(vector<int>& vec)
{
	 vec.push_back(1);
}
//与之对应，值类型会创建副本而非修改原始值，若在主函数中打印参数向量不变
void TestFunc(vector<int> vec)
{
	vec.push_back(1);
}
```


- 在参数中加入[[const]]前缀，使得引用不能被修改(可用于将右引用传入函数参数)
```
 vector<int> ReturnAVector()
{
	vector<int> tempVector;
	return tempVector;
}
 int GetVectorSize(const vector<int>& vector)
 {
	 return vector.size();
 } 

```
# 左引用和右引用

- C++中，引用被区分为左引用和右引用

> [!NOTE] 左引用
> 顾名思义，位于等号左端的引用成为左引用
```
//leftRef即为左引用
string leftRef = "hello world";
```

左引用具有以下特性
- 左引用有明确的储存地址和值，能够储存在电脑的栈和堆中
- 左引用可以直接传入含引用参数的函数


> [!NOTE] 右引用
> 等号右端的引用称为右引用
> 
```
string str = "rightRef"
```
右引用有以下特性
- 右引用相对于左引用，更像一种“临时变量”，没有明确的储存地址
- 右引用不能直接传入含引用参数的函数（毕竟找不到地址，无法修改，在编译阶段就避免犯错），加入[[const]]可传入（只读，保证了准确性）