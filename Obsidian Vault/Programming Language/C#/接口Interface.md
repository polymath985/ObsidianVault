---
tags:
  - CSharp
  - 接口
date: 2025-04-24
---
# 概念

C#中的借口是一个类似于类的东西，可以封装方法属性等内容，相比于类，他可以实现多继承，也可以用来作为约束传参的对象

# 语法

### 接口本身

![[Pasted image 20250424231556.png]]
在.NET 8.0中，C#为我们带来了接口的各种语法，接口中可以写入属性，索引器，公有函数，私有函数，Protected函数，甚至是静态函数和静态属性。

对于属性，其不能含有实例字段，在编译器中，编译后的代码也仅仅含有属性的签名，其相当于对子类的约束，子类必须在其中实现属性。

![[CD22050EECEB1D825293A0CF66DE183B.jpg]]
*图：interface与class的属性区别*

对于函数，其可以是Public,`private`,Protected, Static, Virtual.

| 访问修饰符     | 是否可以不实现 | 原因                  |
| --------- | ------- | ------------------- |
| public    | ✓       | 可以在子类中实现            |
| private   | ×       | 其只有可能在接口内部调用，不实现无意义 |
| protected | ✓       | 可以在子类接口中实现          |
| static    | ×       | 本身即为实例字段，不能不实现      |
| virtual   | ×       | 使用base.时不能没有实例      |
### 继承类

- 类在继承接口后必须实现其中成员或者不包含默认方法的函数
- 在同一个类继承的接口中，若接口有相同的函数成员或者属性，必须借助显式实现
![[Pasted image 20250426211728.png]]
*图：显式实现*

显式实现后，方法前不能写访问修饰符，因为此时无法通过类来调用方法(目的是为了保证调用接口的确定性)，相当于都是`private`

![[Pasted image 20250426214758.png]]
*图：显示实现与隐式实现及其调用*

**下面这张图很有趣，他反映了两个事实**

- 接口中默认方法的实现类似于`virtual`代表的虚方法，也就是说，只要在子类中实现，即使你把它`as` 成父类，调用的仍然是子类中实现的方法
- 同名同访问性的函数，默认会实现父类接口中的方法，即便是不同接口中的方法，也可以被子类中的一个方法实现

![[Pasted image 20250426215114.png]]

- 有趣的是，其仍然可以被显示实现成不同的方法，来达成多态的目的

![[Pasted image 20250426215749.png]]


## 使用

- 进行类的约束，或者实现多态
- 通过接口进行类的部分提取，简化代码结构，提升复用性。相比于基类，接口更加灵活。
  
![[Pasted image 20250426212458.png]]
*图：接口的约束*

在这个例子中，我们只关心array和list的int属性，而不去关心它count，add，remove等，C#为我们提供了`IEnumerable<>`提供共同约束

![[Pasted image 20250426212808.png]]

