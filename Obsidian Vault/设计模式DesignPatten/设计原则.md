---
tags:
  - 设计原则
---
## 单一职责原则

- 一个类只负责一个功能领域中的相应职责

在下面给出的画图工具类中，其只承担描边和画图的职能，而不去管到底`shape`究竟是什么。这样使得画图工具在外界图形种类或者数量发生变化时不受任何干扰，达到单一职责的目的。

```csharp
// 遵循单一职责原则的画图工具类
public class DrawingTool 
{
    public void DrawShape(IShape shape)
    {
        shape.Draw();
    }
    
    public void AddBorder(IShape shape)
    {
        shape.AddBorder();
    }
}

public interface IShape
{
    void Draw();
    void AddBorder();
}
```
*图：画图工具类*

```csharp
// 违反单一职责原则的代码
public class BadDrawingTool 
{
    public void DrawCircle()
    {
        // 绘制圆形的逻辑
        Console.WriteLine("Drawing circle...");
        // 还要处理文件保存
        SaveToFile("circle.png");
        // 还要处理网络传输
        SendToServer("circle data");
    }
    
    public void DrawRectangle()
    {
        // 绘制矩形的逻辑，又重复了保存和传输逻辑
        Console.WriteLine("Drawing rectangle...");
        SaveToFile("rectangle.png");
        SendToServer("rectangle data");
    }
    
    private void SaveToFile(string filename) { /* 文件保存逻辑 */ }
    private void SendToServer(string data) { /* 网络传输逻辑 */ }
}
```
*图：没有遵循单一职责原则的代码*

## 依赖倒置原则

- 高层模块不应该依赖于底层模块，二者都应该依赖于抽象
- 抽象不应该依赖于细节，细节应当依赖于抽象
- 换言之，要面向接口(抽象类)编程，而不是面向实现编程

在下面这个例子中，高层模块(调用者模块)`Graphics`依赖低层模块(被调用者模块)`Rectangle`和`Circle`，这导致底层模块在发生变动时高层模块必须进行修改，不符合低耦合和高复用性的要求

```csharp
// 违反依赖倒置原则 - 高层模块直接依赖底层模块
public class Graphics
{
    public void DrawShapes()
    {
        Rectangle rect = new Rectangle();  // 直接依赖具体类
        Circle circle = new Circle();      // 直接依赖具体类
        
        rect.Draw();
        circle.Draw();
    }
}

public class Rectangle
{
    public void Draw() { Console.WriteLine("Drawing Rectangle"); }
}

public class Circle  
{
    public void Draw() { Console.WriteLine("Drawing Circle"); }
}
```
*图：高层模块依赖于底层模块*

下面这张图片中，高层模块取消了对底层模块的直接以来，转而通过抽象类进行，这样无论`Shape`实现的子类如何改变，都不会影响上层`Graphics`的调用

```csharp
// 遵循依赖倒置原则 - 依赖于抽象
public class Graphics
{
    private readonly IShape[] shapes;
    
    public Graphics(IShape[] shapes)  // 依赖注入
    {
        this.shapes = shapes;
    }
    
    public void DrawShapes()
    {
        foreach(var shape in shapes)
        {
            shape.Draw();  // 依赖抽象接口
        }
    }
}

public interface IShape  // 抽象接口
{
    void Draw();
}

public class Rectangle : IShape
{
    public void Draw() { Console.WriteLine("Drawing Rectangle"); }
}

public class Circle : IShape
{
    public void Draw() { Console.WriteLine("Drawing Circle"); }
}
```
*图：依赖于抽象*

## 开放封闭原则

- 一个软件实体应该对外扩展开放，对内修改关闭，即软件实体应在尽量不修改原有代码的情况下进行扩展

在下面这个例子中，如果添加应该`Triangle`类型，会导致必须对方法进行修改，增加判断条件，这样就增加了代码的耦合度，违背了开放封闭原则和单一职责原则

```csharp
// 违反开放封闭原则 - 需要修改现有代码
public class ShapeDrawer
{
    public void DrawShape(string shapeType)
    {
        if (shapeType == "Rectangle")
        {
            // 绘制矩形逻辑
            Console.WriteLine("Drawing Rectangle");
        }
        else if (shapeType == "Circle")
        {
            // 绘制圆形逻辑
            Console.WriteLine("Drawing Circle");
        }
        // 如果要添加Triangle，必须修改这个方法
        else if (shapeType == "Triangle")
        {
            Console.WriteLine("Drawing Triangle");
        }
    }
}
```
*图：必须进行内部修改*

在下面这张图片中，对功能的实现依赖于注入，从而避免了修改函数内部

```csharp
// 遵循开放封闭原则 - 对扩展开放，对修改关闭
public class ShapeDrawer
{
    public void DrawShape(IShape shape)  // 依赖抽象，不需要修改
    {
        shape.Draw();
    }
}

public interface IShape
{
    void Draw();
}

// 可以无限扩展新的形状类型，无需修改现有代码
public class Triangle : IShape
{
    public void Draw() { Console.WriteLine("Drawing Triangle"); }
}

public class Pentagon : IShape  
{
    public void Draw() { Console.WriteLine("Drawing Pentagon"); }
}
```
*图：注入解耦*

## 接口隔离原则

- 使用多个专门的接口，而不使用单一的总接口

## 里氏替换原则

- 所有基类出现的地方都必能被子类替换，且功能不受到影响 

## 合成复用原则

- 尽量使用对象组合/聚合，而不是通过继承来达到复用的目的

在下面这张图片中，将外部的`Shape`通过传参形式传入，来实现聚合的目的

```csharp
// 合成复用原则 - 使用聚合而非继承
public class GraphicsRenderer
{
    private IShape shape;  // 聚合关系
    
    public GraphicsRenderer(IShape shape)
    {
        this.shape = shape;  // 通过构造函数注入
    }
    
    public void RenderWithEffects()
    {
        AddShadow();
        shape.Draw();  // 委托给聚合的对象
        AddBorder();
    }
    
    private void AddShadow() { Console.WriteLine("Adding shadow effect"); }
    private void AddBorder() { Console.WriteLine("Adding border effect"); }
}
```

在这张图中，类型已经写入父类之中，通过各个组件实现组合的效果

```csharp
// 组合关系的例子
public class Computer
{
    private CPU cpu;           // 组合关系
    private Memory memory;     // 组合关系  
    private HardDisk disk;     // 组合关系
    
    public Computer()
    {
        // 在构造函数中创建组件（组合关系）
        cpu = new CPU("Intel i7");
        memory = new Memory("16GB DDR4");
        disk = new HardDisk("1TB SSD");
    }
    
    public void Start()
    {
        cpu.Process();
        memory.Load();
        disk.Read();
    }
}

public class CPU
{
    public string Type { get; }
    public CPU(string type) { Type = type; }
    public void Process() { Console.WriteLine($"{Type} is processing"); }
}
```
## 迪米特原则

- 也叫最小知识原则，一个软件实体应当尽可能减少与其他实体发生相互作用。类与类的耦合度应该尽可能的低

即尽量至于类内部字段互动，或者与注入的信息互动

```csharp
// 遵循迪米特原则的设计
public class OrderService
{
    private PaymentService paymentService;  // 只与直接依赖交互
    
    public OrderService(PaymentService paymentService)
    {
        this.paymentService = paymentService;
    }
    
    public void ProcessOrder(Order order)
    {
        // 只与自己的字段和参数交互
        order.ValidateItems();
        
        // 通过注入的服务交互，而不是直接访问外部对象
        paymentService.ProcessPayment(order.TotalAmount);
        
        order.MarkAsProcessed();
    }
}
```

这样做会导致类访问外部的实例，而非自身的字段，导致耦合度增大

```csharp
// 违反迪米特原则的设计
public class BadOrderService
{
    public void ProcessOrder(Order order)
    {
        // 违反原则：通过order对象访问其他对象的对象
        order.Customer.PaymentMethod.CreditCard.Validate();
        
        // 违反原则：直接创建和使用外部服务
        EmailService emailService = new EmailService();
        emailService.SendConfirmation(order.Customer.Email);
        
        // 违反原则：访问全局静态实例
        DatabaseManager.Instance.SaveOrder(order);
    }
}
```

> [!NOTE]
> 开闭原则是目标，里氏替换原则是基础，依赖倒置原则是手段
> 最终将不稳定抛到最外层，从而简化代码修改

# 核心思想

- 隔离变化
- 针对接口编程，而不是针对实现编程