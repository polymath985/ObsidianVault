---
tags:
  - 设计模式
---
 
# 工厂方法模式

## 定义

定义一个工厂父类，工厂父类负责定义创建对象的公共接口，而子类负责生成具体的对象。即将类的实例化延迟到工厂类的子类中完成，即由子类来决定应该实例化哪一个类

将简单工厂抽象化，从而达到依赖抽象而不是依赖实现的目的，进而将修改隔离

```csharp
// 抽象工厂接口 - 调用者依赖的抽象
public interface ILoggerFactory
{
    ILogger CreateLogger();
}

// 抽象产品接口
public interface ILogger
{
    void Log(string message);
    void LogError(string error);
}
```
*图：调用者依赖的抽象工厂*

```csharp
// 具体产品类
public class FileLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"File Logger: {message}");
        // 实际实现会写入文件
    }
    
    public void LogError(string error)
    {
        Console.WriteLine($"File Logger Error: {error}");
    }
}

public class DatabaseLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"Database Logger: {message}");
        // 实际实现会写入数据库
    }
    
    public void LogError(string error)
    {
        Console.WriteLine($"Database Logger Error: {error}");
    }
}

// 具体工厂类 - 继承抽象工厂后的实现
public class FileLoggerFactory : ILoggerFactory
{
    public ILogger CreateLogger()
    {
        return new FileLogger();
    }
}

public class DatabaseLoggerFactory : ILoggerFactory
{
    public ILogger CreateLogger()
    {
        return new DatabaseLogger();
    }
}
```
*图：继承抽象工厂后的实现*

```csharp
// 客户端代码 - 通过聚合和注入来实现依赖倒置
public class LogService
{
    private ILoggerFactory loggerFactory;
    
    // 构造函数注入，依赖抽象而不是具体实现
    public LogService(ILoggerFactory factory)
    {
        this.loggerFactory = factory;
    }
    
    public void ProcessLog(string message)
    {
        ILogger logger = loggerFactory.CreateLogger();
        logger.Log(message);
    }
}

// 使用示例
class Program
{
    static void Main(string[] args)
    {
        // 可以轻松切换不同的日志实现，无需修改LogService
        ILoggerFactory factory = new FileLoggerFactory(); // 或者 new DatabaseLoggerFactory()
        LogService service = new LogService(factory);
        
        service.ProcessLog("这是一条日志消息");
    }
}
```
*图：通过聚合和注入来实现依赖倒置*

这样，将不稳定的修改内容隔离在外，通过注入的方式来实现对外拓展开放，对内修改关闭，也就是说，通过**依赖倒置**实现了**开放封闭原则**

```csharp
// 扩展新的日志类型时，无需修改现有代码
public class ConsoleLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"Console Logger: {message}");
    }
    
    public void LogError(string error)
    {
        Console.WriteLine($"Console Logger Error: {error}");
    }
}

public class ConsoleLoggerFactory : ILoggerFactory
{
    public ILogger CreateLogger()
    {
        return new ConsoleLogger();
    }
}
```

```csharp
// 配置文件驱动的工厂选择
public class LoggerFactoryProvider
{
    public static ILoggerFactory GetFactory(string loggerType)
    {
        return loggerType.ToLower() switch
        {
            "file" => new FileLoggerFactory(),
            "database" => new DatabaseLoggerFactory(),
            "console" => new ConsoleLoggerFactory(),
            _ => throw new ArgumentException("Unknown logger type")
        };
    }
}
```

```csharp
// 最终的客户端使用，完全符合开闭原则
class Application
{
    static void Main(string[] args)
    {
        // 从配置文件读取日志类型
        string loggerType = ConfigurationManager.AppSettings["LoggerType"];
        
        // 获取对应的工厂
        ILoggerFactory factory = LoggerFactoryProvider.GetFactory(loggerType);
        
        // 创建服务，完全解耦
        LogService service = new LogService(factory);
        service.ProcessLog("应用程序启动");
    }
}
```

## 优缺点

- **优点**：符合设计原则
- **缺点**：类的个数成本增加，增加了系统的复杂度