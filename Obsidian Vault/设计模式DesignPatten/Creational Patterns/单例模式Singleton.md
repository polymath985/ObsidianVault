---
tags:
  - CSharp
  - 设计模式
aliases:
  - 单例模式
  - Singleton
---
# 定义

在C#中，没有类似于“全局变量”的声明，由此，单例模式应运而生

单例模式是一个类的静态实例封装，可以被全局随时访问，管理被管理的对象

全局唯一性，全局可访问性

**`Instance` `Shared` `Default`**

# 使用

## C Sharp

在C# 6.0之前，我们通过双重判断加锁的形式实现线程安全的单例，如下图所示

在外部第一次尝试获取实例时，`Instance`会首先判断是否为空，若是，则进入锁，锁的作用是在两个线程同时访问`Instance`时，确保下一步是否new的准确性。第二个`if`则在两个线程排队等候时，进行判断，防止出现new两次的情况。

相比于直接在类中new出一个`Instance`这样做有以下优点
- 懒加载：在外部未访问该类的实例时，不加载`Instance`，从而提升程序初始化速度
- 更强的灵活性和安全性：如在Unity中，通过索引器形式可以补充如果`Instance`为空则实例化并加载脚本的过程，防止因空引用导致出错(使用隐式加载确保安全性)

![[3D46973290439D07D88C4F5F801B7B63.png]]
*图：饿汉式单例*

C# 6.0为我们带来了新的语法糖，**自动属性初始化器**

在定义属性时，对于只读自动属性（只有 `get` 访问器 ），可以直接在属性声明后使用 `= 初始化表达式` 的形式进行初始化。例如：

![[BAED01D5E68AF84C30988A70DC33AC51.png]]
*图：自动属性初始化器*

使用时，通过 `Singleton.Instance` 就可以获取到该类的唯一实例，无需像之前版本那样在静态构造函数或其他地方单独初始化

有趣的是，这样做实际上是线程安全的，因为C# CLR 的特性 C# 运行时会确保静态字段的初始化是线程安全的。
当首次访问类的静态成员时 ，CLR（公共语言运行时）会负责按顺序初始化静态字段。CLR 内部会进行同步处理，保证多个线程不会同时对静态字段进行初始化操作，也就避免了多个线程同时创建单例实例的情况。
### 存在的问题

通过索引器的方式，似乎实现了“懒加载”，可实际上，它真的有那么“懒”吗？

![[Pasted image 20250513204047.png]]

![[Pasted image 20250513204158.png]]

上面是代码的执行结果，普通构造函数被调用，这说明`Instance`被new了出来，调用了普通构造，同时，当静态成员被全部初始化后，调用了静态的构造函数。

可是，我们不希望再调用其他静态成员时初始化我们的`Instance`，这说明，我们的实例不够“懒”

### 解决方案

在.NET 4.0 中C# 为我们带来了`Lazy<>`懒加载特性，它可以将实例再次封装为工厂方法，从而使外界访问静态对象时只会初始化`Lazy<>`本身的实例，减小开支。

![[C214C3257D22C354B077A2FDBA7AF868.png]]


![[Pasted image 20250513205623.png]]

从执行结果中我们可以看出，静态成员仍然被全部实例化，包括`Lazy`，但是不同的是，获取`Instance`时对应的普通构造并没有被调用，而是在外界获取`Instance`实例后才被调用，这说明“懒加载”被成功实现。
## Python


# 优势 

相比于直接使用静态类，单例模式有以下优势

- 实现懒加载
- 便于依赖注入和单元测试
- 便于序列化和反序列化































